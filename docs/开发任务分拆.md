
为了确保“作业搭子 (Homework Pal)”项目能够顺利落地，我将之前的 PRD 和技术方案拆解为 **5 个阶段 (Phases)** 共 **12 个具体的开发任务 (Tickets)**。

你可以直接将每一个 Task 的内容复制给你的 AI 结对编程伙伴（如 Cursor/Windsurf），它们包含足够清晰的上下文，能够直接生成可用的代码。

---

### 🗓️ Phase 1: 基础设施与数据层 (Infrastructure & Data)
**目标**：跑通数据库环境，完成表结构设计，确保项目骨架搭建完毕。

#### 🎫 Task 1.1: 项目初始化与环境配置
*   **描述**：初始化 Python 项目，配置依赖管理，搭建 Docker 开发环境。
*   **依赖库**：`uv`, `chainlit`, `sqlalchemy`, `asyncpg`, `dashscope`, `langchain`, `python-dotenv`,`timescale-vector`.
*   **验收标准 (AC)**：
    1.  `uv sync` 能成功安装所有依赖。
    2.  `docker-compose.yml` 能成功启动带有 `pgvector` 插件的 PostgreSQL 16 容器。
    3.  `.env` 文件已创建，包含 `DATABASE_URL` 和 `DASHSCOPE_API_KEY` 占位符。

#### 🎫 Task 1.2: 数据库模型设计 (SQLAlchemy Models)
*   **描述**：根据技术方案，实现 ORM 模型定义。
*   **技术细节**：
    *   文件：`app/models.py`
    *   需定义两个核心模型：
        1.  `TextbookChunk`: 包含 `content`, `embedding` (Vector 1024), `metadata` (JSON).
        2.  `MistakeRecord`: 包含 `student_answer`, `ai_analysis`, `image_path` 等字段。
*   **验收标准 (AC)**：
    1.  运行初始化脚本能自动在 Postgres 中创建这两张表。
    2.  确保 `embedding` 字段正确使用了 `pgvector` 类型。

---

### 🗓️ Phase 2: RAG 核心服务 (The Brain)
**目标**：实现知识库的入库（Ingestion）和检索（Retrieval）。

#### 🎫 Task 2.1: 知识库入库脚本 (Ingestion Script)
*   **描述**：编写脚本，将准备好的文本/Markdown 数据转化为向量存入数据库。
*   **输入**：`data/textbooks/math_grade3_pep.md` (假设已有人工整理好的 Markdown 文件)。
*   **技术细节**：
    *   使用 `BAAI/bge-m3` 模型（通过 `HuggingFaceEmbeddings` 加载）。
    *   使用 `RecursiveCharacterTextSplitter` 进行切片。
    *   使用 `PGVector.from_documents` 存入。
*   **验收标准 (AC)**：
    1.  运行 `python scripts/ingest.py` 后，数据库 `textbook_chunks` 表中有数据。
    2.  数据包含正确的元数据（如 `subject: math`）。

#### 🎫 Task 2.2: 检索服务封装 (RAG Service)
*   **描述**：封装 `RAGService` 类，提供语义搜索接口。
*   **技术细节**：
    *   文件：`app/services/rag.py`
    *   方法：`search(query: str, top_k=3)`。
    *   逻辑：实现“混合检索”的雏形（目前先做纯向量检索，预留关键词过滤接口）。
*   **验收标准 (AC)**：
    1.  编写一个单元测试：输入“周长怎么算”，能返回包含“周长”定义的 Text Chunk。

---

### 🗓️ Phase 3: AI 视觉与推理服务 (Vision & Logic)
**目标**：打通国产大模型 API，实现“看图说话”。

#### 🎫 Task 3.1: 视觉服务封装 (Vision Service)
*   **描述**：封装阿里云 Qwen-VL 的调用逻辑。
*   **技术细节**：
    *   文件：`app/services/vision.py`
    *   方法：`analyze_image(image_path: str, prompt: str)`。
    *   **关键点**：处理 API 的错误重试；确保支持本地图片路径上传。
*   **验收标准 (AC)**：
    1.  输入一张本地图片路径，能获得 Qwen-VL 返回的文本描述。

#### 🎫 Task 3.2: 错题本 CRUD 服务 (Mistake Service)
*   **描述**：实现错题记录的增删改查逻辑。
*   **技术细节**：
    *   文件：`app/services/mistake.py`
    *   方法：`add_mistake(...)`, `get_recent_mistakes(limit=5)`.
    *   使用 `AsyncSession` 进行异步数据库操作。
*   **验收标准 (AC)**：
    1.  调用 `add_mistake` 能在数据库插入一条记录。
    2.  调用 `get_recent_mistakes` 能按时间倒序返回数据。

---

### 🗓️ Phase 4: Chainlit 前端集成 (The UI)
**目标**：将后端服务串联，构建用户界面。

#### 🎫 Task 4.1: 基础聊天框架与 Session 管理
*   **描述**：搭建 Chainlit 主入口，处理用户连接。
*   **技术细节**：
    *   文件：`app/main.py`
    *   实现 `@cl.on_chat_start`：初始化欢迎语，在 `user_session` 中实例化 Service 对象。
*   **验收标准 (AC)**：
    1.  运行 `chainlit run app/main.py` 能打开浏览器。
    2.  看到“小栗子老师”的欢迎语。

#### 🎫 Task 4.2: 图片上传与处理流程 (The Pipeline)
*   **描述**：核心业务逻辑。监听图片上传 -> 调用 Vision -> 调用 RAG -> 生成回复。
*   **技术细节**：
    *   使用 `cl.Step` 显示“正在识别...”、“正在查书...”的状态。
    *   Prompt 需设定为“三年级老师”语气。
*   **验收标准 (AC)**：
    1.  上传图片后，UI 显示进度条。
    2.  最终回复包含：图片识别结果 + 课本知识点引用 + 鼓励性话语。

#### 🎫 Task 4.3: “加入错题本”交互
*   **描述**：在 AI 回复下方添加 Action 按钮，点击后保存数据。
*   **技术细节**：
    *   使用 `cl.Action(name="add_mistake", ...)`。
    *   实现 `@cl.action_callback("add_mistake")`。
*   **验收标准 (AC)**：
    1.  点击按钮，界面提示“已保存”。
    2.  数据库中确实新增了一条记录。

---

### 🗓️ Phase 5: 错题本展示与优化 (Polish)
**目标**：实现错题本的可视化查看。

#### 🎫 Task 5.1: 错题本列表渲染
*   **描述**：响应 `/错题本` 指令，展示错题列表。
*   **技术细节**：
    *   查询 `MistakeService`。
    *   使用 `cl.Message` 发送 Markdown 表格，或使用 `cl.Elements` 发送卡片流。
*   **验收标准 (AC)**：
    1.  输入 `/错题本`，能看到最近存入的错题信息（包含图片缩略图最好）。

#### 🎫 Task 5.2: 导出功能 (可选/进阶)
*   **描述**：生成 Markdown 文件供下载。
*   **技术细节**：
    *   生成一个字符串，包含所有错题内容。
    *   使用 `cl.File` 发送给用户。
*   **验收标准 (AC)**：
    1.  点击下载链接，能下载一个 `.md` 文件，内容排版整齐。

---

### 🚀 给开发者的执行建议

1.  **按顺序执行**：不要跳过 Phase 1，数据库和环境是基础。
2.  **Mock 数据**：在 Phase 2 完成前，可以在 Phase 3 中先用“假数据”测试 UI 流程，避免被 RAG 进度卡住。
3.  **Prompt 调试**：Task 4.2 中的 Prompt 是产品的灵魂，需要多花时间测试（比如故意传一张模糊的图，看 AI 怎么反应）。
